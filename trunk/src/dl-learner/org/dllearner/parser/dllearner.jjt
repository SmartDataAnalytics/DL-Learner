/* Der Parser hat eine andere Darstellung des Baumes als das sp�tere Programm. Es stehen
z.B. die zu einem AND-Knoten geh�rigen Konzepte auf einer Ebene mit dem AND-Knoten, anstatt
darunter. Au�erdem erben hier alle Klassen von SimpleNode. Es w�re m�glich alles so 
umzuschreiben, dass es zu dem sp�teren Programm passt, aber das w�re schwierig und w�rde den
Parser komplexer machen. */

options {
  // MULTI=true;
  JDK_VERSION = "1.5";
  STATIC = false;
}

// wenn der Parser ge�ndert wird, dann muss man in einigen Dateien SuppressWarnings
// einf�gen, wenn man die Warnungen in Eclipse loswerden m�chte

PARSER_BEGIN(DLLearner)
package org.dllearner.parser;

import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.HashSet;
import java.util.SortedSet;
import java.util.TreeSet;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;

import org.dllearner.Main;
import org.dllearner.Info;

import org.dllearner.core.dl.*;
import org.dllearner.ConfigurationOption;
import org.dllearner.utilities.*;

// @SuppressWarnings({"all"})
public class DLLearner {
	
	private static ConceptComparator conceptComparator = new ConceptComparator();
	// hier wird Parse-Fehler angezeigt, obwohl eigentlich alles stimmt??
	private Map<AtomicConcept,SortedSet<Individual>> positiveExamples = new TreeMap<AtomicConcept,SortedSet<Individual>>(conceptComparator);
	private Map<AtomicConcept,SortedSet<Individual>> negativeExamples = new TreeMap<AtomicConcept,SortedSet<Individual>>(conceptComparator);
	
	// Konfigurationsoptionen
	private List<ConfigurationOption> confOptions = new LinkedList<ConfigurationOption>();
	
	// Funktionsaufrufe (die gleiche Funktion darf mehrmals mit unterschiedlichen
	// Argumenten aufgerufen werden)
	// private static Map<String,Set<String>> functionCallsAlt = new TreeMap<String,Set<String>>();
	// jeder Funktionsaufruf hat eine Liste von n Argumenten; alle Funktionsaufrufe
	// werden in einer Liste gespeichert
	private List<List<String>> functionCalls = new LinkedList<List<String>>();
	// => irgendwie Funktionsname + Argumente speichern
	// => d.h. man bräuchte für jede Funktion so eine Liste oder das erste Element
	// der Liste ist der Funktionsname <= ist noch die praktikabelste Variante
	
	// speichert, ob der Parser-Konstruktor aufgerufen wurde: momemtan handelt es
	// sich um einen statischen Parser, d.h. der Konstruktor darf nur einmal
	// aufgerufen werden; weitere Parsevorgänge erfolgen dann mit ReInit
	// TODO: bei einem Webservice braucht man wahrscheinlich einen dynamischen Parser
	// private static boolean constructorCalled = false;
	
	// Wissensbasis
	private KB kb = new KB();
	public static final String internalNamespace = "http://localhost/foo#";
	
	private void addPositiveExample(AtomicConcept conceptName, Individual instanceName) {
		if(positiveExamples.containsKey(conceptName)) {
			positiveExamples.get(conceptName).add(instanceName);
		} else {
			SortedSet<Individual> newTarget = new TreeSet<Individual>();
			newTarget.add(instanceName);
			positiveExamples.put(conceptName,newTarget);
		}
	}
	
	private void addNegativeExample(AtomicConcept conceptName, Individual instanceName) {
		if(negativeExamples.containsKey(conceptName)) {
			negativeExamples.get(conceptName).add(instanceName);
		} else {
			SortedSet<Individual> newTarget = new TreeSet<Individual>();
			newTarget.add(instanceName);
			negativeExamples.put(conceptName,newTarget);
		}		
	}	
	
	public Map<AtomicConcept,SortedSet<Individual>> getPositiveExamples() {
		return positiveExamples;
	}
	
	public Map<AtomicConcept,SortedSet<Individual>> getNegativeExamples() {
		return negativeExamples;
	}
	
	public List<ConfigurationOption> getConfOptions() {
		return confOptions;
	}
	
	public List<List<String>> getFunctionCalls() {
		return functionCalls;
	}
	
	public KB getKB() {
		return kb;
	}
	
	/*
	private static void addFunctionCall(String functionName, String argument) {
		if(functionCalls.containsKey(functionName)) {
			functionCalls.get(functionName).add(argument);
		} else {
			Set<String> newFunction = new TreeSet<String>();
			newFunction.add(argument);
			functionCalls.put(functionName,newFunction);
		}		
	}
	*/	
	
	// Methode um allen internen Sachen eine URI zu geben (ist zwar für DLs nicht
	// notwendig, aber bei Ontologien schon und die interne KB soll eine Ontologie
	// repräsentieren
	public static String getInternalURI(String name) {
		if(name.startsWith("http://"))
			return name;
		else
			return internalNamespace + name;
	}
	
	public static SimpleNode parseString(String str) throws ParseException {
		StringReader sr = new StringReader(str);
		DLLearner learner = new DLLearner(sr);
		SimpleNode n = learner.Start();
		return n;
	}
	
	public static Concept parseConcept(String str) throws ParseException {
		StringReader sr = new StringReader(str);
		DLLearner learner = new DLLearner(sr);
		// 		
		//SimpleNode n = DLLearner.Start();
		//return n;	
		/*
		Concept c = null;	
		try {

			c = DLLearner.Concept();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
		Concept c = learner.Concept();		
		
		return c;
	}
	
	public static DLLearner parseFile(String filename) {
		DLLearner learner = null;
		try {
			learner = new DLLearner(new FileInputStream(filename));
			learner.Start();
		} catch(FileNotFoundException e) {
			e.printStackTrace();
		} catch(ParseException e) {
			e.printStackTrace();
		}
		return learner;
	}
	
  public static void main(String args[]) {

    if(args.length==0) {
        System.out.println("Please specify an input file.");
        System.exit(0);
    }

    System.out.println("Starting DL-Learner (Build " + Info.build + ")");
	// System.out.println(args);
 
	// System.out.println(args[0]);
	// System.out.println(args[1]);
	// System.out.println(args.length);

    File f = new File(args[args.length-1]);
    String baseDir = "";

	System.out.print("Parsing " + f.getName() + " ... ");
    long parseStartTime = System.currentTimeMillis();

    SimpleNode n = null;
    DLLearner learner = null;
    try {
        learner = new DLLearner(new FileInputStream(args[args.length-1]));
        baseDir = f.getParentFile().getPath();    	
    } catch(IOException e) {
        System.err.println(e);
        System.exit(0);
    }
    try {
      n = learner.Start();
      // n.dump("");
      // System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("\nParse exception occurred. Please follow the advise given below.");
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(0);
    }

    long parseDuration = System.currentTimeMillis() - parseStartTime;
    System.out.println("OK (" + parseDuration + " ms)");

    boolean queryMode = false;
    // solution test mode wird nicht unbedingt gebraucht, da man die covers
    // gleich standardmäßig beim query mit anzeigen kann
    // boolean solutionTestMode = false;
    
    if(args.length>1 && args[0].equals("-q"))
    	queryMode = true;
    
    //if(args.length>1 && args[0].equals("-qt")) {
    //	queryMode = true;
    //	solutionTestMode = true;
    //}
    
    // new Main(n, baseDir, queryMode);
    // Parser erstmal Standalone testen
    // n.dump("");
    
    // neuer Aufruf des Hauptprogramms
    // TODO: remove (in the future, the parser will be called from whatever method
    // needs it, instead of starting the learning process itself)
    // new Main(kb,positiveExamples,negativeExamples,confOptions,functionCalls,baseDir,queryMode);
  }
}
PARSER_END(DLLearner)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
} 

TOKEN :
{
    < COMMAND_END: "." >
  | < CONF_END: ";" >
  | < POS_EX: "+" >
  | < NEG_EX: "-" >
  | < ID: ["a"-"z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
  | < NUMBER: (["1"-"9"] (["0"-"9"])* | "0") >
  | < DOUBLE: (["1"-"9"] (["0"-"9"])* | "0") "." (["0"-"9"])* >
  | <TOP: "TOP" >
  | <BOTTOM: "BOTTOM" >
  | <AND: "AND" >
  | <OR: "OR" >
  | <EXISTS: "EXISTS" | "SOME" >
  | <ALL: "ALL" | "FORALL" >
  | <NOT: "NEG" | "NOT" >
  | <GE: ">=" >
  | <LE: "<=" >
  | <STRING: "\"" (~["\"","\\","\n","\r"])* "\"">
}

/* Grob�berblick:
  	 	Id() [ "." Id() ] "="  ( Id() | Number() ) <CONF_END>	// Konfigurationsoption
  	|	Id() "(" String() ")" <CONF_END>
  	| 	<POS_EX> Id() "(" Id() ")" <COMMAND_END>  	// positives Beispiel
  	|	<NEG_EX> Id() "(" Id() ")" <COMMAND_END>  	// negatives Beispiel
  	|	Id() "(" Id() "," Id() ")" <COMMAND_END>  	// ABox - Rolle
  	|	Concept() "(" Id() ")" <COMMAND_END>     	// ABox - Konzept
  	|	"Transitive" + "(" + Id() ")" <COMMAND_END>		// transitive Rollen, analog transitiv, funktional
  	|	"Inverse" + "(" + Id() + "," + Id() + ")" <COMMAND_END>	// Rolle 1 invers zu Rolle 2
  	|	"Subrole" + "(" + Id() + "," + Id() + ")" <COMMAND_END>	// Rolle 1 Teilmenge von Rolle 2
  	|	Concept() "=" Concept() <COMMAND_END>		// TBox - �quivalenz von Konzepten
  	|	Concept() "SUBCLASS" Concept() <COMMAND_END> 	// TBox - Konzept 1 Teilmenge von Konzept 2
*/
SimpleNode Start() : 
{
	ConceptAssertion conceptAssertion;
	RoleAssertion roleAssertion;
	RBoxAxiom rBoxAxiom;
	Equality equality;
	Inclusion inclusion;
	ConfigurationOption confOption;
}
{
  (		// bei Konfigurationsoption geht der Parser bis zum Semikolon durch, da das das einzige
  		// sichere Unterscheidungsmerkmal ist
  		LOOKAHEAD(Id() [ "." Id() ] "="  ( Id() | Integer() | Double() | String() 
  		  | "{" "}" | "{" ( ( String() | Id() ) "," )* (String() | Id()) "}" ) <CONF_END>)  confOption=ConfOption()
  		  { confOptions.add(confOption); }
  	|	LOOKAHEAD(Id() "(" String() ("," String())* ")" <CONF_END>) FunctionCall()
  		// positive bzw. negative Beispiele sind an "+" bzw. "-" erkennbar
  	|	LOOKAHEAD(<POS_EX>) PosExample()
  	|	LOOKAHEAD(<NEG_EX>) NegExample()
  	|   LOOKAHEAD(Concept() "(" Individual() ")" <COMMAND_END>) conceptAssertion=ABoxConcept()
  		{ kb.addABoxAxiom(conceptAssertion); }
  		// bei ABox - Rolle muss bis zum Komma gegangen werden
  	|	LOOKAHEAD([Not()] AtomicRole() "(" Individual() ",") roleAssertion = ABoxRole()
  		{ kb.addABoxAxiom(roleAssertion); }	
  	|	rBoxAxiom = Transitive()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	| 	rBoxAxiom = Functional()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Symmetric()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Inverse()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Subrole()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  		// da Konfigurationsoptionen ausgeschlossen sind, reicht es bis zum "=" zu suchen
  	|	LOOKAHEAD(Concept() "=") equality = TBoxEquiv()
  		{ kb.addTBoxAxiom(equality); }
  	|	LOOKAHEAD(Concept() ("SUBCLASSOF" | "SUB" )) inclusion = TBoxSub()
  		{ kb.addTBoxAxiom(inclusion); }
  )*
  <EOF>
  { return jjtThis; }
}

KB parseKB() :
{
	KB kb = null;
}
{
	<EOF>
	{return kb; }
}

ConfigurationOption ConfOption() : 
{
	boolean containsSubOption=false, isNumeric=false, isDouble=false, isSet=false;
	String option="", subOption="", value="", tmp=""; 
	int number = 0;
	double numberDouble = 0;
	ConfigurationOption confOption;
	Set<String> values = new HashSet<String>();
}
{
  option=Id() [ "." subOption=Id() {containsSubOption=true;} ] 
  "="  (   value=Id() 
         | value=String()
         | number=Integer() {isNumeric=true;} 
         | numberDouble=Double() {isNumeric=true; isDouble=true;} 
         | LOOKAHEAD("{" "}") "{" "}" {isSet=true;} // leere Menge 
         | "{" ( LOOKAHEAD(2) ( tmp=String() | tmp=Id() ) {values.add(tmp);} "," )* 
           (tmp=String() | tmp=Id()) {values.add(tmp);} "}" {isSet=true;}
           // eine Liste von ein oder mehr Elementen in Mengenschreibweise
         ) <CONF_END>
  {
  	if(containsSubOption) {
  		if(isNumeric)
  			if(isDouble)
	  			confOption = new ConfigurationOption(option,subOption,numberDouble);
	  		else
		  		confOption = new ConfigurationOption(option,subOption,number);
  		else
  			if(isSet)
  				confOption = new ConfigurationOption(option,subOption,values);
  			else
  				confOption = new ConfigurationOption(option,subOption,value);
  	} else {
  		if(isNumeric)
  			if(isDouble)
	  			confOption = new ConfigurationOption(option,numberDouble);
	  		else
	  			confOption = new ConfigurationOption(option,number);
  		else
  			if(isSet)
	  			confOption = new ConfigurationOption(option,values);
	  		else
	  			confOption = new ConfigurationOption(option,value);
  	}
  	return confOption;
  	// confOptions.add(confOption);
  }
}

void FunctionCall() : 
{
	String s, s1, s2;
	List<String> list = new LinkedList<String>();
}
{
  	s1=Id() "(" s2=String() { list.add(s1); list.add(s2); }
  	("," s=String() { list.add(s); } )* ")" <CONF_END>
  	{ functionCalls.add(list); }
}

void PosExample() : { AtomicConcept ac; Individual i; }
{
  	<POS_EX> ac=AtomicConcept() "(" i=Individual() ")" <COMMAND_END>
  	{ addPositiveExample(ac,i); }
}

void NegExample() : { AtomicConcept ac; Individual i; }
{
  	<NEG_EX> ac=AtomicConcept() "(" i=Individual() ")" <COMMAND_END>
  	{ addNegativeExample(ac,i); }
}

ConceptAssertion ABoxConcept() : {Concept c; Individual i;}
{
	c=Concept() "(" i=Individual() ")" <COMMAND_END>
	{ return new ConceptAssertion(c,i); }	
}

RoleAssertion ABoxRole() : 
{ 
	boolean isNegated=false; 
	AtomicRole ar;
	Individual i1,i2;
}
{
   	[Not() {isNegated=true;}] ar=AtomicRole() "(" i1=Individual() "," i2=Individual() ")" <COMMAND_END>
   	{
   		if(isNegated)
   			throw new Error("negated role assertions not supported yet");
   		else
   			return new RoleAssertion(ar,i1,i2);
   	}
}

TransitiveRoleAxiom Transitive() : {AtomicRole ar;}
{
   "Transitive" "(" ar=AtomicRole() ")" <COMMAND_END>
   { return new TransitiveRoleAxiom(ar); }
}

FunctionalRoleAxiom Functional() : {AtomicRole ar;}
{
   "Functional" "(" ar=AtomicRole() ")" <COMMAND_END>
   { return new FunctionalRoleAxiom(ar); }
   
}

SymmetricRoleAxiom Symmetric() : {AtomicRole ar;}
{
   "Symmetric" "(" ar=AtomicRole() ")" <COMMAND_END>
   { return new SymmetricRoleAxiom(ar); }
}

InverseRoleAxiom Inverse() : {AtomicRole ar1,ar2;}
{
   "Inverse" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>
   { return new InverseRoleAxiom(ar1,ar2); }
}

SubRoleAxiom Subrole() : {AtomicRole ar1,ar2;}
{
   "Subrole" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>
   { return new SubRoleAxiom(ar1,ar2);}
}

/******* PARSER OHNE EIGENE METHODEN FÜR ATOMIC CONCEPT/ROLE *** DEPRECATED
void PosExample() : {String s1="",s2="";}
{
  	<POS_EX> (s1=Id()|s1=String()) "(" (s2=Id()|s2=String()) ")" <COMMAND_END>
  	{ addPositiveExample(s1,s2); }
}

void NegExample() : {String s1="",s2="";}
{
  	<NEG_EX> [s1=Id()|s1=String()] "(" [s2=Id()|s2=String()] ")" <COMMAND_END>
  	{ addNegativeExample(s1,s2); }
}

ConceptAssertion ABoxConcept() : {Concept c; String s;}
{
	c=Concept() "(" s=Id() ")" <COMMAND_END>
	{ return new ConceptAssertion(c,s); }	
}

RoleAssertion ABoxRole() : { boolean isNegated=false; String s1,s2,s3;}
{
   	[Not() {isNegated=true;}] s1=Id() "(" s2=Id() "," s3=Id() ")" <COMMAND_END>
   	{
   		if(isNegated)
   			throw new Error("negated role assertions not supported yet");
   		else
   			return new RoleAssertion(new AtomicRole(s1),s2,s3);
   	}
}

TransitiveRoleAxiom Transitive() : {String s;}
{
   "Transitive" "(" s=Id() ")" <COMMAND_END>
   { return new TransitiveRoleAxiom(new AtomicRole(s)); }
}

FunctionalRoleAxiom Functional() : {String s;}
{
   "Functional" "(" s=Id() ")" <COMMAND_END>
   { return new FunctionalRoleAxiom(new AtomicRole(s)); }
   
}

SymmetricRoleAxiom Symmetric() : {String s;}
{
   "Symmetric" "(" s=Id() ")" <COMMAND_END>
   { return new SymmetricRoleAxiom(new AtomicRole(s)); }
}

InverseRoleAxiom Inverse() : {String s1,s2;}
{
   "Inverse" "(" s1=Id() "," s2=Id() ")" <COMMAND_END>
   { return new InverseRoleAxiom(new AtomicRole(s1),new AtomicRole(s2)); }
}

SubRoleAxiom Subrole() : {String s1,s2;}
{
   "Subrole" "(" s1=Id() "," s2=Id() ")" <COMMAND_END>
   { return new SubRoleAxiom(new AtomicRole(s1),new AtomicRole(s2));}
}
****************************************************************/

Equality TBoxEquiv() : {Concept c1,c2;}
{
   c1=Concept() "=" c2=Concept() <COMMAND_END>
   { return new Equality(c1,c2); }
}

Inclusion TBoxSub() : {Concept c1,c2;}
{
   c1=Concept() ("SUBCLASSOF" | "SUB" | "SUBCONCEPTOF") c2=Concept() <COMMAND_END>
   { return new Inclusion(c1,c2);}
}

// TODO: Support f�r inverse Rollen
Concept Concept() : 
{
	Concept c,c1,c2;
	AtomicConcept ac;
	AtomicRole ar;
	String s;
	int i;
}
{
    Top() {return new Top();}
  | Bottom() {return new Bottom();}
  | ac = AtomicConcept() {return ac;}
  // | s=Id() {return new AtomicConcept(s);}
  // | s=String() {return new AtomicConcept(s);} 
  // Parser geht bis zum n�chsten AND oder OR
  | LOOKAHEAD( "(" Concept() And())    "(" c1=Concept() And() c2=Concept() ")" 
  	{return new Conjunction(c1,c2);}
  | LOOKAHEAD( "(" Concept() Or())    "(" c1=Concept() Or() c2=Concept() ")"
  	{return new Disjunction(c1,c2);}
  // EXISTS oder ALL reicht aus um richtigen Zweig zu w�hlen
  // | Exists() s=Id() "." c=Concept()
  // {return new Exists(new AtomicRole(s),c); } 
  | Exists() ar=AtomicRole() "." c=Concept()
  	{return new Exists(ar,c); } 
  // | All() s=Id() "." c=Concept()
  //	{return new All(new AtomicRole(s),c); }
  | All() ar=AtomicRole() "." c=Concept()
	{return new All(ar,c); }	
  | Not() c=Concept()
  	{return new Negation(c); }
  // | GE() i=Integer() s=Id() "." c=Concept()
  //	{return new GreaterEqual(i,new AtomicRole(s),c);}
  | GE() i=Integer() ar=AtomicRole() "." c=Concept()
  	{return new GreaterEqual(i,ar,c);}  	
  // | LE() i=Integer() s=Id() "." c=Concept()
  //	{return new LessEqual(i,new AtomicRole(s),c);}
  | LE() i=Integer() ar=AtomicRole() "." c=Concept()
  	{return new LessEqual(i,ar,c);}  	
}

void Or() : {} { <OR> }
void And() : {} { <AND> }
void Top() : {} { <TOP> }
void Bottom() : {} { <BOTTOM> } 
void Exists() : {} { <EXISTS> }
void All() : {} { <ALL> }
void Not() : {} { <NOT> }
void GE() : {} { <GE> }
void LE() : {} { <LE> }

AtomicConcept AtomicConcept() :
{
	String name;
}
{
	(name=Id() | name=String())
	{
		return new AtomicConcept(getInternalURI(name));
	}
}

AtomicRole AtomicRole() :
{
	String name;
}
{
	(name=Id() | name=String())
	{
		return new AtomicRole(getInternalURI(name));
	}
}

Individual Individual() :
{
	String name;
}
{
	(name=Id() | name=String())
	{
		return new Individual(getInternalURI(name));
	}
}

String Id() : 
{
  Token t;
}
{
  t=<ID>
  {
    // jjtThis.setId(t.image);
    return t.image;
  }
}

double Double() : 
{
  Token t;
}
{
  t=<DOUBLE>
  {
    return new Double(t.image);
  }
}

int Integer() : 
{
  Token t;
}
{
  t=<NUMBER>
  {
    // jjtThis.setId(t.image);
    // muss noch in Integer umgewandelt werden
    return new Integer(t.image);
  }
}

String String() : 
{
  Token t;
  String s;
}
{
  t=<STRING>
  {
    // jjtThis.setId(t.image);
    // es werden sofort die Anfuehrungszeichen abgeschnitten
    s = t.image;
    s = s.substring(1, s.length() - 1);
    return s;
  }
}
