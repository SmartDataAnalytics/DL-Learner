/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./kb.jj */
/*@egen*//**
 * Copyright (C) 2007, Jens Lehmann
 *
 * This file is part of DL-Learner.
 * 
 * DL-Learner is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DL-Learner is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * KB file parser.
 */

options {
  JDK_VERSION = "1.5";
  STATIC = false;
}
 
PARSER_BEGIN(KBParser) 
package org.dllearner.parser;

import org.dllearner.core.dl.*;

public class KBParser/*@bgen(jjtree)*/implements KBParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTKBParserState jjtree = new JJTKBParserState();

/*@egen*/

	public static final String internalNamespace = "http://localhost/foo#";

	// method to give all internal stuff an URI (not necessary for DLs, but for OWL ontologies
	// and it should be possible to represent the internal KB as OWL ontology)
	public static String getInternalURI(String name) {
		if(name.startsWith("http://"))
			return name;
		else
			return internalNamespace + name;
	}

}
PARSER_END(KBParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
} 

TOKEN :
{
    < COMMAND_END: "." >
  | < ID: ["a"-"z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
  | < NUMBER: (["1"-"9"] (["0"-"9"])* | "0") >
  | < DOUBLE: (["1"-"9"] (["0"-"9"])* | "0") "." (["0"-"9"])* >
  | < TOP: "TOP" >
  | < BOTTOM: "BOTTOM" >
  | < AND: "AND" >
  | < OR: "OR" >
  | < EXISTS: "EXISTS" | "SOME" >
  | < ALL: "ALL" | "FORALL" >
  | < NOT: "NEG" | "NOT" >
  | < GE: ">=" >
  | < LE: "<=" >
  | < STRING: "\"" (~["\"","\\","\n","\r"])* "\"">
}

KB KB() :
{/*@bgen(jjtree) KB */
        SimpleNode jjtn000 = new SimpleNode(JJTKB);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	ConceptAssertion conceptAssertion;
	RoleAssertion roleAssertion;
	RBoxAxiom rBoxAxiom;
	Equality equality;
	Inclusion inclusion;
	KB kb = new KB();
}
{/*@bgen(jjtree) KB */
  try {
/*@egen*/
  (		LOOKAHEAD(Concept() "(" Individual() ")" <COMMAND_END>) conceptAssertion=ABoxConcept()
  		{ kb.addABoxAxiom(conceptAssertion); }
  	|	LOOKAHEAD([Not()] AtomicRole() "(" Individual() ",") roleAssertion = ABoxRole()
  		{ kb.addABoxAxiom(roleAssertion); }	
  	|	rBoxAxiom = Transitive()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	| 	rBoxAxiom = Functional()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Symmetric()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Inverse()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Subrole()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  		// da Konfigurationsoptionen ausgeschlossen sind, reicht es bis zum "=" zu suchen
  	|	LOOKAHEAD(Concept() "=") equality = TBoxEquiv()
  		{ kb.addTBoxAxiom(equality); }
  	|	LOOKAHEAD(Concept() ("SUBCLASSOF" | "SUB" )) inclusion = TBoxSub()
  		{ kb.addTBoxAxiom(inclusion); }
  )*
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return kb; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ConceptAssertion ABoxConcept() : {/*@bgen(jjtree) ABoxConcept */
                                  SimpleNode jjtn000 = new SimpleNode(JJTABOXCONCEPT);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c; Individual i;}
{/*@bgen(jjtree) ABoxConcept */
        try {
/*@egen*/
	c=Concept() "(" i=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return new ConceptAssertion(c,i); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

RoleAssertion ABoxRole() : 
{/*@bgen(jjtree) ABoxRole */
        SimpleNode jjtn000 = new SimpleNode(JJTABOXROLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	boolean isNegated=false; 
	AtomicRole ar;
	Individual i1,i2;
}
{/*@bgen(jjtree) ABoxRole */
        try {
/*@egen*/
   	[Not() {isNegated=true;}] ar=AtomicRole() "(" i1=Individual() "," i2=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
   	{
   		if(isNegated)
   			throw new Error("negated role assertions not supported yet");
   		else
   			return new RoleAssertion(ar,i1,i2);
   	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TransitiveRoleAxiom Transitive() : {/*@bgen(jjtree) Transitive */
                                    SimpleNode jjtn000 = new SimpleNode(JJTTRANSITIVE);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Transitive */
   try {
/*@egen*/
   "Transitive" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new TransitiveRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

FunctionalRoleAxiom Functional() : {/*@bgen(jjtree) Functional */
                                    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONAL);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Functional */
   try {
/*@egen*/
   "Functional" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new FunctionalRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
   
}

SymmetricRoleAxiom Symmetric() : {/*@bgen(jjtree) Symmetric */
                                  SimpleNode jjtn000 = new SimpleNode(JJTSYMMETRIC);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Symmetric */
   try {
/*@egen*/
   "Symmetric" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new SymmetricRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

InverseRoleAxiom Inverse() : {/*@bgen(jjtree) Inverse */
                              SimpleNode jjtn000 = new SimpleNode(JJTINVERSE);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar1,ar2;}
{/*@bgen(jjtree) Inverse */
   try {
/*@egen*/
   "Inverse" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new InverseRoleAxiom(ar1,ar2); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

SubRoleAxiom Subrole() : {/*@bgen(jjtree) Subrole */
                          SimpleNode jjtn000 = new SimpleNode(JJTSUBROLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar1,ar2;}
{/*@bgen(jjtree) Subrole */
   try {
/*@egen*/
   "Subrole" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new SubRoleAxiom(ar1,ar2);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Equality TBoxEquiv() : {/*@bgen(jjtree) TBoxEquiv */
                        SimpleNode jjtn000 = new SimpleNode(JJTTBOXEQUIV);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c1,c2;}
{/*@bgen(jjtree) TBoxEquiv */
   try {
/*@egen*/
   c1=Concept() "=" c2=Concept() <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new Equality(c1,c2); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Inclusion TBoxSub() : {/*@bgen(jjtree) TBoxSub */
                       SimpleNode jjtn000 = new SimpleNode(JJTTBOXSUB);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c1,c2;}
{/*@bgen(jjtree) TBoxSub */
   try {
/*@egen*/
   c1=Concept() ("SUBCLASSOF" | "SUB" | "SUBCONCEPTOF") c2=Concept() <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new Inclusion(c1,c2);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Concept Concept() : 
{/*@bgen(jjtree) Concept */
        SimpleNode jjtn000 = new SimpleNode(JJTCONCEPT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Concept c,c1,c2;
	AtomicConcept ac;
	AtomicRole ar;
	String s;
	int i;
}
{/*@bgen(jjtree) Concept */
    try {
/*@egen*/
    Top()/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {return new Top();}
  | Bottom()/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {return new Bottom();}
  | ac = AtomicConcept()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {return ac;}
  // | s=Id() {return new AtomicConcept(s);}
  // | s=String() {return new AtomicConcept(s);} 
  // Parser geht bis zum n\ufffdchsten AND oder OR
  | LOOKAHEAD( "(" Concept() And())    "(" c1=Concept() And() c2=Concept() ")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
  	{return new Conjunction(c1,c2);}
  | LOOKAHEAD( "(" Concept() Or())    "(" c1=Concept() Or() c2=Concept() ")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Disjunction(c1,c2);}
  // EXISTS oder ALL reicht aus um richtigen Zweig zu w\ufffdhlen
  // | Exists() s=Id() "." c=Concept()
  // {return new Exists(new AtomicRole(s),c); } 
  | Exists() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Exists(ar,c); } 
  // | All() s=Id() "." c=Concept()
  //	{return new All(new AtomicRole(s),c); }
  | All() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return new All(ar,c); }	
  | Not() c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Negation(c); }
  // | GE() i=Integer() s=Id() "." c=Concept()
  //	{return new GreaterEqual(i,new AtomicRole(s),c);}
  | GE() i=Integer() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new GreaterEqual(i,ar,c);}  	
  // | LE() i=Integer() s=Id() "." c=Concept()
  //	{return new LessEqual(i,new AtomicRole(s),c);}
  | LE() i=Integer() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new LessEqual(i,ar,c);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  	
}

void Or() : {/*@bgen(jjtree) Or */
  SimpleNode jjtn000 = new SimpleNode(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Or */
                 try {
/*@egen*/ <OR>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }
void And() : {/*@bgen(jjtree) And */
  SimpleNode jjtn000 = new SimpleNode(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) And */
                  try {
/*@egen*/ <AND>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Top() : {/*@bgen(jjtree) Top */
  SimpleNode jjtn000 = new SimpleNode(JJTTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Top */
                  try {
/*@egen*/ <TOP>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Bottom() : {/*@bgen(jjtree) Bottom */
  SimpleNode jjtn000 = new SimpleNode(JJTBOTTOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Bottom */
                     try {
/*@egen*/ <BOTTOM>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/ } 
void Exists() : {/*@bgen(jjtree) Exists */
  SimpleNode jjtn000 = new SimpleNode(JJTEXISTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Exists */
                     try {
/*@egen*/ <EXISTS>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/ }
void All() : {/*@bgen(jjtree) All */
  SimpleNode jjtn000 = new SimpleNode(JJTALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) All */
                  try {
/*@egen*/ <ALL>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Not() : {/*@bgen(jjtree) Not */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Not */
                  try {
/*@egen*/ <NOT>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void GE() : {/*@bgen(jjtree) GE */
  SimpleNode jjtn000 = new SimpleNode(JJTGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) GE */
                 try {
/*@egen*/ <GE>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }
void LE() : {/*@bgen(jjtree) LE */
  SimpleNode jjtn000 = new SimpleNode(JJTLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) LE */
                 try {
/*@egen*/ <LE>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }

AtomicConcept AtomicConcept() :
{/*@bgen(jjtree) AtomicConcept */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICCONCEPT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) AtomicConcept */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new AtomicConcept(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

AtomicRole AtomicRole() :
{/*@bgen(jjtree) AtomicRole */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICROLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) AtomicRole */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new AtomicRole(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Individual Individual() :
{/*@bgen(jjtree) Individual */
        SimpleNode jjtn000 = new SimpleNode(JJTINDIVIDUAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) Individual */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new Individual(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String Id() : 
{/*@bgen(jjtree) Id */
  SimpleNode jjtn000 = new SimpleNode(JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Id */
  try {
/*@egen*/
  t=<ID>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    return t.image;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

double Double() : 
{/*@bgen(jjtree) Double */
  SimpleNode jjtn000 = new SimpleNode(JJTDOUBLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Double */
  try {
/*@egen*/
  t=<DOUBLE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return new Double(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int Integer() : 
{/*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Integer */
  try {
/*@egen*/
  t=<NUMBER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    // muss noch in Integer umgewandelt werden
    return new Integer(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String String() : 
{/*@bgen(jjtree) String */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  String s;
}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  t=<STRING>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    // es werden sofort die Anfuehrungszeichen abgeschnitten
    s = t.image;
    s = s.substring(1, s.length() - 1);
    return s;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}