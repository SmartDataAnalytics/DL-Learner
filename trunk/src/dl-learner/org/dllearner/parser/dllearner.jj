/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./dllearner.jj */
/*@egen*//* Der Parser hat eine andere Darstellung des Baumes als das sp\ufffdtere Programm. Es stehen
z.B. die zu einem AND-Knoten geh\ufffdrigen Konzepte auf einer Ebene mit dem AND-Knoten, anstatt
darunter. Au\ufffderdem erben hier alle Klassen von SimpleNode. Es w\ufffdre m\ufffdglich alles so 
umzuschreiben, dass es zu dem sp\ufffdteren Programm passt, aber das w\ufffdre schwierig und w\ufffdrde den
Parser komplexer machen. */

options {
  // MULTI=true;
  JDK_VERSION = "1.5";
  STATIC = false;
}

// wenn der Parser ge\ufffdndert wird, dann muss man in einigen Dateien SuppressWarnings
// einf\ufffdgen, wenn man die Warnungen in Eclipse loswerden m\ufffdchte

PARSER_BEGIN(DLLearner)
package org.dllearner.parser;

import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.HashSet;
import java.util.SortedSet;
import java.util.TreeSet;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;

import org.dllearner.Main;
import org.dllearner.Info;

import org.dllearner.core.dl.*;
import org.dllearner.ConfigurationOption;
import org.dllearner.utilities.*;

// @SuppressWarnings({"all"})
public class DLLearner/*@bgen(jjtree)*/implements DLLearnerTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTDLLearnerState jjtree = new JJTDLLearnerState();

/*@egen*/
	
	private static ConceptComparator conceptComparator = new ConceptComparator();
	// hier wird Parse-Fehler angezeigt, obwohl eigentlich alles stimmt??
	private Map<AtomicConcept,SortedSet<Individual>> positiveExamples = new TreeMap<AtomicConcept,SortedSet<Individual>>(conceptComparator);
	private Map<AtomicConcept,SortedSet<Individual>> negativeExamples = new TreeMap<AtomicConcept,SortedSet<Individual>>(conceptComparator);
	
	// Konfigurationsoptionen
	private List<ConfigurationOption> confOptions = new LinkedList<ConfigurationOption>();
	
	// Funktionsaufrufe (die gleiche Funktion darf mehrmals mit unterschiedlichen
	// Argumenten aufgerufen werden)
	// private static Map<String,Set<String>> functionCallsAlt = new TreeMap<String,Set<String>>();
	// jeder Funktionsaufruf hat eine Liste von n Argumenten; alle Funktionsaufrufe
	// werden in einer Liste gespeichert
	private List<List<String>> functionCalls = new LinkedList<List<String>>();
	// => irgendwie Funktionsname + Argumente speichern
	// => d.h. man br\u00e4uchte f\u00fcr jede Funktion so eine Liste oder das erste Element
	// der Liste ist der Funktionsname <= ist noch die praktikabelste Variante
	
	// speichert, ob der Parser-Konstruktor aufgerufen wurde: momemtan handelt es
	// sich um einen statischen Parser, d.h. der Konstruktor darf nur einmal
	// aufgerufen werden; weitere Parsevorg\u00e4nge erfolgen dann mit ReInit
	// TODO: bei einem Webservice braucht man wahrscheinlich einen dynamischen Parser
	// private static boolean constructorCalled = false;
	
	// Wissensbasis
	private KB kb = new KB();
	public static final String internalNamespace = "http://localhost/foo#";
	
	private void addPositiveExample(AtomicConcept conceptName, Individual instanceName) {
		if(positiveExamples.containsKey(conceptName)) {
			positiveExamples.get(conceptName).add(instanceName);
		} else {
			SortedSet<Individual> newTarget = new TreeSet<Individual>();
			newTarget.add(instanceName);
			positiveExamples.put(conceptName,newTarget);
		}
	}
	
	private void addNegativeExample(AtomicConcept conceptName, Individual instanceName) {
		if(negativeExamples.containsKey(conceptName)) {
			negativeExamples.get(conceptName).add(instanceName);
		} else {
			SortedSet<Individual> newTarget = new TreeSet<Individual>();
			newTarget.add(instanceName);
			negativeExamples.put(conceptName,newTarget);
		}		
	}	
	
	public Map<AtomicConcept,SortedSet<Individual>> getPositiveExamples() {
		return positiveExamples;
	}
	
	public Map<AtomicConcept,SortedSet<Individual>> getNegativeExamples() {
		return negativeExamples;
	}
	
	public List<ConfigurationOption> getConfOptions() {
		return confOptions;
	}
	
	public List<List<String>> getFunctionCalls() {
		return functionCalls;
	}
	
	public KB getKB() {
		return kb;
	}
	
	/*
	private static void addFunctionCall(String functionName, String argument) {
		if(functionCalls.containsKey(functionName)) {
			functionCalls.get(functionName).add(argument);
		} else {
			Set<String> newFunction = new TreeSet<String>();
			newFunction.add(argument);
			functionCalls.put(functionName,newFunction);
		}		
	}
	*/	
	
	// Methode um allen internen Sachen eine URI zu geben (ist zwar f\u00fcr DLs nicht
	// notwendig, aber bei Ontologien schon und die interne KB soll eine Ontologie
	// repr\u00e4sentieren
	public static String getInternalURI(String name) {
		if(name.startsWith("http://"))
			return name;
		else
			return internalNamespace + name;
	}
	
	public static SimpleNode parseString(String str) throws ParseException {
		StringReader sr = new StringReader(str);
		DLLearner learner = new DLLearner(sr);
		SimpleNode n = learner.Start();
		return n;
	}
	
	public static Concept parseConcept(String str) throws ParseException {
		StringReader sr = new StringReader(str);
		DLLearner learner = new DLLearner(sr);
		// 		
		//SimpleNode n = DLLearner.Start();
		//return n;	
		/*
		Concept c = null;	
		try {

			c = DLLearner.Concept();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
		Concept c = learner.Concept();		
		
		return c;
	}
	
	public static DLLearner parseFile(String filename) {
		DLLearner learner = null;
		try {
			learner = new DLLearner(new FileInputStream(filename));
			learner.Start();
		} catch(FileNotFoundException e) {
			e.printStackTrace();
		} catch(ParseException e) {
			e.printStackTrace();
		}
		return learner;
	}
	
  public static void main(String args[]) {

    if(args.length==0) {
        System.out.println("Please specify an input file.");
        System.exit(0);
    }

    System.out.println("Starting DL-Learner (Build " + Info.build + ")");
	// System.out.println(args);
 
	// System.out.println(args[0]);
	// System.out.println(args[1]);
	// System.out.println(args.length);

    File f = new File(args[args.length-1]);
    String baseDir = "";

	System.out.print("Parsing " + f.getName() + " ... ");
    long parseStartTime = System.currentTimeMillis();

    SimpleNode n = null;
    DLLearner learner = null;
    try {
        learner = new DLLearner(new FileInputStream(args[args.length-1]));
        baseDir = f.getParentFile().getPath();    	
    } catch(IOException e) {
        System.err.println(e);
        System.exit(0);
    }
    try {
      n = learner.Start();
      // n.dump("");
      // System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("\nParse exception occurred. Please follow the advise given below.");
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(0);
    }

    long parseDuration = System.currentTimeMillis() - parseStartTime;
    System.out.println("OK (" + parseDuration + " ms)");

    boolean queryMode = false;
    // solution test mode wird nicht unbedingt gebraucht, da man die covers
    // gleich standardm\u00e4\u00dfig beim query mit anzeigen kann
    // boolean solutionTestMode = false;
    
    if(args.length>1 && args[0].equals("-q"))
    	queryMode = true;
    
    //if(args.length>1 && args[0].equals("-qt")) {
    //	queryMode = true;
    //	solutionTestMode = true;
    //}
    
    // new Main(n, baseDir, queryMode);
    // Parser erstmal Standalone testen
    // n.dump("");
    
    // neuer Aufruf des Hauptprogramms
    // TODO: remove (in the future, the parser will be called from whatever method
    // needs it, instead of starting the learning process itself)
    // new Main(kb,positiveExamples,negativeExamples,confOptions,functionCalls,baseDir,queryMode);
  }
}
PARSER_END(DLLearner)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
} 

TOKEN :
{
    < COMMAND_END: "." >
  | < CONF_END: ";" >
  | < POS_EX: "+" >
  | < NEG_EX: "-" >
  | < ID: ["a"-"z"] (["_","a"-"z","A"-"Z","0"-"9"])* >
  | < NUMBER: (["1"-"9"] (["0"-"9"])* | "0") >
  | < DOUBLE: (["1"-"9"] (["0"-"9"])* | "0") "." (["0"-"9"])* >
  | <TOP: "TOP" >
  | <BOTTOM: "BOTTOM" >
  | <AND: "AND" >
  | <OR: "OR" >
  | <EXISTS: "EXISTS" | "SOME" >
  | <ALL: "ALL" | "FORALL" >
  | <NOT: "NEG" | "NOT" >
  | <GE: ">=" >
  | <LE: "<=" >
  | <STRING: "\"" (~["\"","\\","\n","\r"])* "\"">
}

/* Grob\ufffdberblick:
  	 	Id() [ "." Id() ] "="  ( Id() | Number() ) <CONF_END>	// Konfigurationsoption
  	|	Id() "(" String() ")" <CONF_END>
  	| 	<POS_EX> Id() "(" Id() ")" <COMMAND_END>  	// positives Beispiel
  	|	<NEG_EX> Id() "(" Id() ")" <COMMAND_END>  	// negatives Beispiel
  	|	Id() "(" Id() "," Id() ")" <COMMAND_END>  	// ABox - Rolle
  	|	Concept() "(" Id() ")" <COMMAND_END>     	// ABox - Konzept
  	|	"Transitive" + "(" + Id() ")" <COMMAND_END>		// transitive Rollen, analog transitiv, funktional
  	|	"Inverse" + "(" + Id() + "," + Id() + ")" <COMMAND_END>	// Rolle 1 invers zu Rolle 2
  	|	"Subrole" + "(" + Id() + "," + Id() + ")" <COMMAND_END>	// Rolle 1 Teilmenge von Rolle 2
  	|	Concept() "=" Concept() <COMMAND_END>		// TBox - \ufffdquivalenz von Konzepten
  	|	Concept() "SUBCLASS" Concept() <COMMAND_END> 	// TBox - Konzept 1 Teilmenge von Konzept 2
*/
SimpleNode Start() : 
{/*@bgen(jjtree) Start */
        SimpleNode jjtn000 = new SimpleNode(JJTSTART);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	ConceptAssertion conceptAssertion;
	RoleAssertion roleAssertion;
	RBoxAxiom rBoxAxiom;
	Equality equality;
	Inclusion inclusion;
	ConfigurationOption confOption;
}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  (		// bei Konfigurationsoption geht der Parser bis zum Semikolon durch, da das das einzige
  		// sichere Unterscheidungsmerkmal ist
  		LOOKAHEAD(Id() [ "." Id() ] "="  ( Id() | Integer() | Double() | String() 
  		  | "{" "}" | "{" ( ( String() | Id() ) "," )* (String() | Id()) "}" ) <CONF_END>)  confOption=ConfOption()
  		  { confOptions.add(confOption); }
  	|	LOOKAHEAD(Id() "(" String() ("," String())* ")" <CONF_END>) FunctionCall()
  		// positive bzw. negative Beispiele sind an "+" bzw. "-" erkennbar
  	|	LOOKAHEAD(<POS_EX>) PosExample()
  	|	LOOKAHEAD(<NEG_EX>) NegExample()
  	|   LOOKAHEAD(Concept() "(" Individual() ")" <COMMAND_END>) conceptAssertion=ABoxConcept()
  		{ kb.addABoxAxiom(conceptAssertion); }
  		// bei ABox - Rolle muss bis zum Komma gegangen werden
  	|	LOOKAHEAD([Not()] AtomicRole() "(" Individual() ",") roleAssertion = ABoxRole()
  		{ kb.addABoxAxiom(roleAssertion); }	
  	|	rBoxAxiom = Transitive()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	| 	rBoxAxiom = Functional()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Symmetric()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Inverse()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  	|	rBoxAxiom = Subrole()
  		{ kb.addRBoxAxiom(rBoxAxiom); }
  		// da Konfigurationsoptionen ausgeschlossen sind, reicht es bis zum "=" zu suchen
  	|	LOOKAHEAD(Concept() "=") equality = TBoxEquiv()
  		{ kb.addTBoxAxiom(equality); }
  	|	LOOKAHEAD(Concept() ("SUBCLASSOF" | "SUB" )) inclusion = TBoxSub()
  		{ kb.addTBoxAxiom(inclusion); }
  )*
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

KB parseKB() :
{/*@bgen(jjtree) parseKB */
        SimpleNode jjtn000 = new SimpleNode(JJTPARSEKB);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	KB kb = null;
}
{/*@bgen(jjtree) parseKB */
        try {
/*@egen*/
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return kb; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ConfigurationOption ConfOption() : 
{/*@bgen(jjtree) ConfOption */
        SimpleNode jjtn000 = new SimpleNode(JJTCONFOPTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	boolean containsSubOption=false, isNumeric=false, isDouble=false, isSet=false;
	String option="", subOption="", value="", tmp=""; 
	int number = 0;
	double numberDouble = 0;
	ConfigurationOption confOption;
	Set<String> values = new HashSet<String>();
}
{/*@bgen(jjtree) ConfOption */
  try {
/*@egen*/
  option=Id() [ "." subOption=Id() {containsSubOption=true;} ] 
  "="  (   value=Id() 
         | value=String()
         | number=Integer() {isNumeric=true;} 
         | numberDouble=Double() {isNumeric=true; isDouble=true;} 
         | LOOKAHEAD("{" "}") "{" "}" {isSet=true;} // leere Menge 
         | "{" ( LOOKAHEAD(2) ( tmp=String() | tmp=Id() ) {values.add(tmp);} "," )* 
           (tmp=String() | tmp=Id()) {values.add(tmp);} "}" {isSet=true;}
           // eine Liste von ein oder mehr Elementen in Mengenschreibweise
         ) <CONF_END>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	if(containsSubOption) {
  		if(isNumeric)
  			if(isDouble)
	  			confOption = new ConfigurationOption(option,subOption,numberDouble);
	  		else
		  		confOption = new ConfigurationOption(option,subOption,number);
  		else
  			if(isSet)
  				confOption = new ConfigurationOption(option,subOption,values);
  			else
  				confOption = new ConfigurationOption(option,subOption,value);
  	} else {
  		if(isNumeric)
  			if(isDouble)
	  			confOption = new ConfigurationOption(option,numberDouble);
	  		else
	  			confOption = new ConfigurationOption(option,number);
  		else
  			if(isSet)
	  			confOption = new ConfigurationOption(option,values);
	  		else
	  			confOption = new ConfigurationOption(option,value);
  	}
  	return confOption;
  	// confOptions.add(confOption);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FunctionCall() : 
{/*@bgen(jjtree) FunctionCall */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONCALL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String s, s1, s2;
	List<String> list = new LinkedList<String>();
}
{/*@bgen(jjtree) FunctionCall */
        try {
/*@egen*/
  	s1=Id() "(" s2=String() { list.add(s1); list.add(s2); }
  	("," s=String() { list.add(s); } )* ")" <CONF_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{ functionCalls.add(list); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PosExample() : {/*@bgen(jjtree) PosExample */
                      SimpleNode jjtn000 = new SimpleNode(JJTPOSEXAMPLE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ AtomicConcept ac; Individual i; }
{/*@bgen(jjtree) PosExample */
        try {
/*@egen*/
  	<POS_EX> ac=AtomicConcept() "(" i=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{ addPositiveExample(ac,i); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NegExample() : {/*@bgen(jjtree) NegExample */
                      SimpleNode jjtn000 = new SimpleNode(JJTNEGEXAMPLE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ AtomicConcept ac; Individual i; }
{/*@bgen(jjtree) NegExample */
        try {
/*@egen*/
  	<NEG_EX> ac=AtomicConcept() "(" i=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{ addNegativeExample(ac,i); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ConceptAssertion ABoxConcept() : {/*@bgen(jjtree) ABoxConcept */
                                  SimpleNode jjtn000 = new SimpleNode(JJTABOXCONCEPT);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c; Individual i;}
{/*@bgen(jjtree) ABoxConcept */
        try {
/*@egen*/
	c=Concept() "(" i=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return new ConceptAssertion(c,i); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

RoleAssertion ABoxRole() : 
{/*@bgen(jjtree) ABoxRole */
        SimpleNode jjtn000 = new SimpleNode(JJTABOXROLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	boolean isNegated=false; 
	AtomicRole ar;
	Individual i1,i2;
}
{/*@bgen(jjtree) ABoxRole */
        try {
/*@egen*/
   	[Not() {isNegated=true;}] ar=AtomicRole() "(" i1=Individual() "," i2=Individual() ")" <COMMAND_END>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
   	{
   		if(isNegated)
   			throw new Error("negated role assertions not supported yet");
   		else
   			return new RoleAssertion(ar,i1,i2);
   	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TransitiveRoleAxiom Transitive() : {/*@bgen(jjtree) Transitive */
                                    SimpleNode jjtn000 = new SimpleNode(JJTTRANSITIVE);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Transitive */
   try {
/*@egen*/
   "Transitive" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new TransitiveRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

FunctionalRoleAxiom Functional() : {/*@bgen(jjtree) Functional */
                                    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONAL);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Functional */
   try {
/*@egen*/
   "Functional" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new FunctionalRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
   
}

SymmetricRoleAxiom Symmetric() : {/*@bgen(jjtree) Symmetric */
                                  SimpleNode jjtn000 = new SimpleNode(JJTSYMMETRIC);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar;}
{/*@bgen(jjtree) Symmetric */
   try {
/*@egen*/
   "Symmetric" "(" ar=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new SymmetricRoleAxiom(ar); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

InverseRoleAxiom Inverse() : {/*@bgen(jjtree) Inverse */
                              SimpleNode jjtn000 = new SimpleNode(JJTINVERSE);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar1,ar2;}
{/*@bgen(jjtree) Inverse */
   try {
/*@egen*/
   "Inverse" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new InverseRoleAxiom(ar1,ar2); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

SubRoleAxiom Subrole() : {/*@bgen(jjtree) Subrole */
                          SimpleNode jjtn000 = new SimpleNode(JJTSUBROLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/AtomicRole ar1,ar2;}
{/*@bgen(jjtree) Subrole */
   try {
/*@egen*/
   "Subrole" "(" ar1=AtomicRole() "," ar2=AtomicRole() ")" <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new SubRoleAxiom(ar1,ar2);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/******* PARSER OHNE EIGENE METHODEN F\u00dcR ATOMIC CONCEPT/ROLE *** DEPRECATED
void PosExample() : {String s1="",s2="";}
{
  	<POS_EX> (s1=Id()|s1=String()) "(" (s2=Id()|s2=String()) ")" <COMMAND_END>
  	{ addPositiveExample(s1,s2); }
}

void NegExample() : {String s1="",s2="";}
{
  	<NEG_EX> [s1=Id()|s1=String()] "(" [s2=Id()|s2=String()] ")" <COMMAND_END>
  	{ addNegativeExample(s1,s2); }
}

ConceptAssertion ABoxConcept() : {Concept c; String s;}
{
	c=Concept() "(" s=Id() ")" <COMMAND_END>
	{ return new ConceptAssertion(c,s); }	
}

RoleAssertion ABoxRole() : { boolean isNegated=false; String s1,s2,s3;}
{
   	[Not() {isNegated=true;}] s1=Id() "(" s2=Id() "," s3=Id() ")" <COMMAND_END>
   	{
   		if(isNegated)
   			throw new Error("negated role assertions not supported yet");
   		else
   			return new RoleAssertion(new AtomicRole(s1),s2,s3);
   	}
}

TransitiveRoleAxiom Transitive() : {String s;}
{
   "Transitive" "(" s=Id() ")" <COMMAND_END>
   { return new TransitiveRoleAxiom(new AtomicRole(s)); }
}

FunctionalRoleAxiom Functional() : {String s;}
{
   "Functional" "(" s=Id() ")" <COMMAND_END>
   { return new FunctionalRoleAxiom(new AtomicRole(s)); }
   
}

SymmetricRoleAxiom Symmetric() : {String s;}
{
   "Symmetric" "(" s=Id() ")" <COMMAND_END>
   { return new SymmetricRoleAxiom(new AtomicRole(s)); }
}

InverseRoleAxiom Inverse() : {String s1,s2;}
{
   "Inverse" "(" s1=Id() "," s2=Id() ")" <COMMAND_END>
   { return new InverseRoleAxiom(new AtomicRole(s1),new AtomicRole(s2)); }
}

SubRoleAxiom Subrole() : {String s1,s2;}
{
   "Subrole" "(" s1=Id() "," s2=Id() ")" <COMMAND_END>
   { return new SubRoleAxiom(new AtomicRole(s1),new AtomicRole(s2));}
}
****************************************************************/

Equality TBoxEquiv() : {/*@bgen(jjtree) TBoxEquiv */
                        SimpleNode jjtn000 = new SimpleNode(JJTTBOXEQUIV);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c1,c2;}
{/*@bgen(jjtree) TBoxEquiv */
   try {
/*@egen*/
   c1=Concept() "=" c2=Concept() <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new Equality(c1,c2); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Inclusion TBoxSub() : {/*@bgen(jjtree) TBoxSub */
                       SimpleNode jjtn000 = new SimpleNode(JJTTBOXSUB);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Concept c1,c2;}
{/*@bgen(jjtree) TBoxSub */
   try {
/*@egen*/
   c1=Concept() ("SUBCLASSOF" | "SUB" | "SUBCONCEPTOF") c2=Concept() <COMMAND_END>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new Inclusion(c1,c2);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

// TODO: Support f\ufffdr inverse Rollen
Concept Concept() : 
{/*@bgen(jjtree) Concept */
        SimpleNode jjtn000 = new SimpleNode(JJTCONCEPT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Concept c,c1,c2;
	AtomicConcept ac;
	AtomicRole ar;
	String s;
	int i;
}
{/*@bgen(jjtree) Concept */
    try {
/*@egen*/
    Top()/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {return new Top();}
  | Bottom()/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {return new Bottom();}
  | ac = AtomicConcept()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {return ac;}
  // | s=Id() {return new AtomicConcept(s);}
  // | s=String() {return new AtomicConcept(s);} 
  // Parser geht bis zum n\ufffdchsten AND oder OR
  | LOOKAHEAD( "(" Concept() And())    "(" c1=Concept() And() c2=Concept() ")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
  	{return new Conjunction(c1,c2);}
  | LOOKAHEAD( "(" Concept() Or())    "(" c1=Concept() Or() c2=Concept() ")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Disjunction(c1,c2);}
  // EXISTS oder ALL reicht aus um richtigen Zweig zu w\ufffdhlen
  // | Exists() s=Id() "." c=Concept()
  // {return new Exists(new AtomicRole(s),c); } 
  | Exists() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Exists(ar,c); } 
  // | All() s=Id() "." c=Concept()
  //	{return new All(new AtomicRole(s),c); }
  | All() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return new All(ar,c); }	
  | Not() c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new Negation(c); }
  // | GE() i=Integer() s=Id() "." c=Concept()
  //	{return new GreaterEqual(i,new AtomicRole(s),c);}
  | GE() i=Integer() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new GreaterEqual(i,ar,c);}  	
  // | LE() i=Integer() s=Id() "." c=Concept()
  //	{return new LessEqual(i,new AtomicRole(s),c);}
  | LE() i=Integer() ar=AtomicRole() "." c=Concept()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return new LessEqual(i,ar,c);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  	
}

void Or() : {/*@bgen(jjtree) Or */
  SimpleNode jjtn000 = new SimpleNode(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Or */
                 try {
/*@egen*/ <OR>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }
void And() : {/*@bgen(jjtree) And */
  SimpleNode jjtn000 = new SimpleNode(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) And */
                  try {
/*@egen*/ <AND>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Top() : {/*@bgen(jjtree) Top */
  SimpleNode jjtn000 = new SimpleNode(JJTTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Top */
                  try {
/*@egen*/ <TOP>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Bottom() : {/*@bgen(jjtree) Bottom */
  SimpleNode jjtn000 = new SimpleNode(JJTBOTTOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Bottom */
                     try {
/*@egen*/ <BOTTOM>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/ } 
void Exists() : {/*@bgen(jjtree) Exists */
  SimpleNode jjtn000 = new SimpleNode(JJTEXISTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Exists */
                     try {
/*@egen*/ <EXISTS>/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/ }
void All() : {/*@bgen(jjtree) All */
  SimpleNode jjtn000 = new SimpleNode(JJTALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) All */
                  try {
/*@egen*/ <ALL>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void Not() : {/*@bgen(jjtree) Not */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Not */
                  try {
/*@egen*/ <NOT>/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
                  }
/*@egen*/ }
void GE() : {/*@bgen(jjtree) GE */
  SimpleNode jjtn000 = new SimpleNode(JJTGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) GE */
                 try {
/*@egen*/ <GE>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }
void LE() : {/*@bgen(jjtree) LE */
  SimpleNode jjtn000 = new SimpleNode(JJTLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) LE */
                 try {
/*@egen*/ <LE>/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/ }

AtomicConcept AtomicConcept() :
{/*@bgen(jjtree) AtomicConcept */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICCONCEPT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) AtomicConcept */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new AtomicConcept(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

AtomicRole AtomicRole() :
{/*@bgen(jjtree) AtomicRole */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICROLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) AtomicRole */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new AtomicRole(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Individual Individual() :
{/*@bgen(jjtree) Individual */
        SimpleNode jjtn000 = new SimpleNode(JJTINDIVIDUAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
}
{/*@bgen(jjtree) Individual */
        try {
/*@egen*/
	(name=Id() | name=String())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return new Individual(getInternalURI(name));
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String Id() : 
{/*@bgen(jjtree) Id */
  SimpleNode jjtn000 = new SimpleNode(JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Id */
  try {
/*@egen*/
  t=<ID>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    return t.image;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

double Double() : 
{/*@bgen(jjtree) Double */
  SimpleNode jjtn000 = new SimpleNode(JJTDOUBLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Double */
  try {
/*@egen*/
  t=<DOUBLE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return new Double(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int Integer() : 
{/*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Integer */
  try {
/*@egen*/
  t=<NUMBER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    // muss noch in Integer umgewandelt werden
    return new Integer(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String String() : 
{/*@bgen(jjtree) String */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  String s;
}
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  t=<STRING>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // jjtThis.setId(t.image);
    // es werden sofort die Anfuehrungszeichen abgeschnitten
    s = t.image;
    s = s.substring(1, s.length() - 1);
    return s;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
