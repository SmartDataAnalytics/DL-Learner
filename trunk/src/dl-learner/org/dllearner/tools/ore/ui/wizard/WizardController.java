/**
 * Copyright (C) 2007-2008, Jens Lehmann
 *
 * This file is part of DL-Learner.
 * 
 * DL-Learner is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DL-Learner is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.dllearner.tools.ore.ui.wizard;


import java.awt.Cursor;
import java.awt.event.ActionListener;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.swing.JOptionPane;
import javax.swing.SwingWorker;

import org.dllearner.core.owl.Description;
import org.dllearner.core.owl.NamedClass;
import org.dllearner.tools.ore.OREManager;
import org.dllearner.tools.ore.ui.StatusBar;
import org.dllearner.tools.ore.ui.wizard.descriptors.ClassChoosePanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.InconsistencyExplanationPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.KnowledgeSourcePanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.LearningPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.RepairPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.UnsatisfiableExplanationPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.panels.ClassChoosePanel;
import org.semanticweb.owl.model.OWLOntologyChange;

/**
 * This class is responsible for reacting to events generated by pushing any of the
 * three buttons, 'Next', 'Previous', and 'Cancel.' Based on what button is pressed,
 * the controller will update the model to show a new panel and reset the state of
 * the buttons as necessary.
 * @author Lorenz Buehmann
 */
public class WizardController implements ActionListener {
    
    private Wizard wizard;
    
    /**
     * This constructor accepts a reference to the Wizard component that created it,
     * which it uses to update the button components and access the WizardModel.
     * @param w A callback to the Wizard component that created this controller.
     */    
    public WizardController(Wizard w) {
        wizard = w;
    }

    /**
     * Calling method for the action listener interface. This class listens for actions
     * performed by the buttons in the Wizard class, and calls methods below to determine
     * the correct course of action.
     * @param evt The ActionEvent that occurred.
     */    
    public void actionPerformed(java.awt.event.ActionEvent evt) {
        
        if (evt.getActionCommand().equals(Wizard.CANCEL_BUTTON_ACTION_COMMAND)){
            cancelButtonPressed();
        } else if (evt.getActionCommand().equals(Wizard.BACK_BUTTON_ACTION_COMMAND)){
            backButtonPressed();
        } else if (evt.getActionCommand().equals(Wizard.NEXT_BUTTON_ACTION_COMMAND)){
            nextButtonPressed();
        }
    }
    
    
    
    private void cancelButtonPressed() {
        
        wizard.close(Wizard.CANCEL_RETURN_CODE);
    }

    private void nextButtonPressed() {
 
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor currentPanelDescriptor = model.getCurrentPanelDescriptor();
        OREManager ore = OREManager.getInstance();
        //  If it is a finishable panel, close down the dialog. Otherwise,
        //  get the ID that the current panel identifies as the next panel,
        //  and display it.
        
        Object nextPanelDescriptor = currentPanelDescriptor.getNextPanelDescriptor();
        WizardPanelDescriptor nextDescriptor = model.getPanelHashMap().get(nextPanelDescriptor);
        
        if(nextPanelDescriptor.equals(KnowledgeSourcePanelDescriptor.IDENTIFIER)){
        	
        	KnowledgeSourcePanelDescriptor knowledgeDescriptor = ((KnowledgeSourcePanelDescriptor) model.getPanelHashMap().get(nextPanelDescriptor));
        	knowledgeDescriptor.addMetricsPanel();
        	        	
        }
        if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals
        		(KnowledgeSourcePanelDescriptor.IDENTIFIER)){
        	
        	
        	if(!ore.consistentOntology()){
        		
        		
        		int n = showInconsistentOntologyWarning();

        		if(n == JOptionPane.NO_OPTION){
        			nextPanelDescriptor = KnowledgeSourcePanelDescriptor.IDENTIFIER;
        		} else {
        			InconsistencyExplanationPanelDescriptor incDescriptor = new InconsistencyExplanationPanelDescriptor();
                    wizard.registerWizardPanel(InconsistencyExplanationPanelDescriptor.IDENTIFIER, incDescriptor);
                    ((InconsistencyExplanationPanelDescriptor)model.getPanelHashMap().get(InconsistencyExplanationPanelDescriptor.IDENTIFIER)).init();
                    
                    wizard.registerWizardPanel(InconsistencyExplanationPanelDescriptor.IDENTIFIER, incDescriptor);
                    nextPanelDescriptor = InconsistencyExplanationPanelDescriptor.IDENTIFIER;
        		}
        		
        		
        	} else {
        		ClassificationWorker task = new ClassificationWorker(wizard.getStatusBar());
        		task.execute();
        		
        	
        		if(ore.getPelletReasoner().getInconsistentClasses().size() > 0 ){
        			UnsatisfiableExplanationPanelDescriptor unsatDescriptor = new UnsatisfiableExplanationPanelDescriptor();
        			wizard.registerWizardPanel(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER, unsatDescriptor);
        			((UnsatisfiableExplanationPanelDescriptor)model.getPanelHashMap().get(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER)).init();
        			wizard.registerWizardPanel(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER, unsatDescriptor);
        			nextPanelDescriptor = UnsatisfiableExplanationPanelDescriptor.IDENTIFIER;
        		} else {
        			
        			nextPanelDescriptor = ClassChoosePanelDescriptor.IDENTIFIER;
        			((ClassChoosePanelDescriptor) nextDescriptor).getOwlClassPanel().getClassesTable().clear();
                	new ConceptRetriever(nextPanelDescriptor).execute();
        		}
        		
        	}
//        	wizard.getStatusBar().setMessage("");wizard.getStatusBar().showProgress(false);
        	
        }
        if(currentPanelDescriptor.equals(InconsistencyExplanationPanelDescriptor.IDENTIFIER)){
        	ore.getPelletReasoner().classify();
        	if(ore.getPelletReasoner().getInconsistentClasses().size() > 0 ){
        		
        	} else {
        		nextPanelDescriptor = KnowledgeSourcePanelDescriptor.IDENTIFIER;
        	}
        }
        if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER)){
        	nextPanelDescriptor = ClassChoosePanelDescriptor.IDENTIFIER;
			((ClassChoosePanelDescriptor) nextDescriptor).getOwlClassPanel().getClassesTable().clear();
			((ClassChoosePanelDescriptor) nextDescriptor).getOwlClassPanel().getClassesTable().addClasses(OREManager.getInstance().getPelletReasoner().getNamedClasses());
//        	new ConceptRetriever(nextPanelDescriptor).execute();
        }
       
        if(nextPanelDescriptor.equals("LEARNING_PANEL")){
        	ore.setLearningProblem();
        	LearningPanelDescriptor learnDescriptor = ((LearningPanelDescriptor) model.getPanelHashMap().get(nextPanelDescriptor));
        	learnDescriptor.setPanelDefaults();
        	        	
        }
        
        if(nextPanelDescriptor.equals("REPAIR_PANEL")){
        	RepairPanelDescriptor repair = ((RepairPanelDescriptor) model.getPanelHashMap().get(nextPanelDescriptor));
        	repair.refreshExampleLists();
        	
//        	OWLOntologyChange change = model.getOre().getModi().addAxiomToOWL(model.getOre().getConceptToAdd(), model.getOre().getIgnoredConcept());
//        	repair.getOntologyChanges().add(change);

        }
        
        if(nextPanelDescriptor.equals("SAVE_PANEL")){

        	Description newDesc = ore.getNewClassDescription().getDescription();
        	Description oldClass = ore.getCurrentClass2Learn();
        	
        	List<OWLOntologyChange> changes = ore.getModifier().rewriteClassDescription(newDesc, oldClass);
        	((RepairPanelDescriptor) currentPanelDescriptor).getOntologyChanges().addAll(changes);
                	
        }
        
        
        if (nextPanelDescriptor instanceof WizardPanelDescriptor.FinishIdentifier) {
            wizard.close(Wizard.FINISH_RETURN_CODE);
        } else {        
            wizard.setCurrentPanel(nextPanelDescriptor);
        }
        
        //TODO
        refreshLeftPanel(nextPanelDescriptor);
        
        
        
        
        
    }
    
    
    private void backButtonPressed() {
 
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
 
        //  Get the descriptor that the current panel identifies as the previous
        //  panel, and display it.
        
        Object backPanelDescriptor = descriptor.getBackPanelDescriptor();        
        
        
        if(backPanelDescriptor.equals("LEARNING_PANEL")){
        	RepairPanelDescriptor repairDescriptor = (RepairPanelDescriptor) descriptor;
        	if(repairDescriptor.getOntologyChanges().size() > 0){
	        	if (JOptionPane.showConfirmDialog(wizard.getDialog(),
				        "All changes will be lost!", "Warning!", 
				        JOptionPane.YES_NO_OPTION)
				     == JOptionPane.YES_OPTION){
	
	        		OREManager.getInstance().getModifier().undoChanges(repairDescriptor.getOntologyChanges());
	        		repairDescriptor.getOntologyChanges().clear();
					wizard.setCurrentPanel(backPanelDescriptor);
			        refreshLeftPanel(backPanelDescriptor);
				}
        	} else{
        		wizard.setCurrentPanel(backPanelDescriptor);
		        refreshLeftPanel(backPanelDescriptor);
        	}
        	
        	
        	
        } else if(backPanelDescriptor.equals("CLASS_CHOOSE_OWL_PANEL")){
        	LearningPanelDescriptor learnDescriptor = (LearningPanelDescriptor) descriptor;
        	if(learnDescriptor.getLa() != null){
        		learnDescriptor.getLa().stop();
        		learnDescriptor.getTimer().cancel();
        	}
        	
        	wizard.setCurrentPanel(backPanelDescriptor);
	        refreshLeftPanel(backPanelDescriptor);
    	
        }else{
        	wizard.setCurrentPanel(backPanelDescriptor);
            refreshLeftPanel(backPanelDescriptor);
        }
        
        
    }
    
    void refreshLeftPanel(Object panelDescriptor){
    	
    	if(panelDescriptor.equals("INTRODUCTION_PANEL")){
        	wizard.setLeftPanel(0);
        }
    	if(panelDescriptor.equals("KNOWLEDGESOURCE_CHOOSE_PANEL")){
        	wizard.setLeftPanel(1);
        }
    	if(panelDescriptor.equals("CLASS_CHOOSE_OWL_PANEL") || panelDescriptor.equals("CLASS_CHOOSE_SPARQL_PANEL")){
        	wizard.setLeftPanel(2);
        }
    	if(panelDescriptor.equals("LEARNING_PANEL")){
        	wizard.setLeftPanel(3);
        }
    	if(panelDescriptor.equals("REPAIR_PANEL")){
        	wizard.setLeftPanel(4);
        }
    	if(panelDescriptor.equals("SAVE_PANEL")){
        	wizard.setLeftPanel(5);
        }
    	
    	
        
    }
    
    private int showInconsistentOntologyWarning(){
//    	Exception e = new Exception("ff");
		String infoString = "<html>Can not do reasoning with inconsistent ontologies, " +
				"since everything is equivalent to owl:nothing\n" +
				"<ul>" +
				"<li>Press 'Yes' and try to repair the ontology</li>" +
				"<li>Press 'No' and choose another ontology or exit</li>" +
				"</ul></html>";
//		ErrorInfo info = new ErrorInfo("Warning: Inconsistent ontology.",infoString , wizard.getModel().getOre().getInconsistencyExplanationsString(), null, e, Level.ALL, null);
//		JXErrorPane error = new JXErrorPane();
//		Icon icon = UIManager.getIcon("OptionPane.warningIcon");
//		error.setErrorInfo(info);
//		error.setIcon(icon);
//		JXErrorPane.showDialog(wizard.getDialog(), error);
		
		Object[] options = {"Yes",
        "No"};

		int n = JOptionPane.showOptionDialog(wizard.getDialog(),
			    infoString,
			    "Inconsistent ontology loaded!",
			    JOptionPane.YES_NO_OPTION,
			    JOptionPane.WARNING_MESSAGE,
			    null,     //do not use a custom Icon
			    options,  //the titles of buttons
			    options[0]); //default button title
		
		return n;
		
    }
    
    

    
    void resetButtonsToPanelRules() {
    
        //  Reset the buttons to support the original panel rules,
        //  including whether the next or back buttons are enabled or
        //  disabled, or if the panel is finishable.
        
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
        
        model.setCancelButtonText(Wizard.CANCEL_TEXT);
//        model.setCancelButtonIcon(Wizard.CANCEL_ICON);
        
        //  If the panel in question has another panel behind it, enable
        //  the back button. Otherwise, disable it.
        
        model.setBackButtonText(Wizard.BACK_TEXT);

        
        if (descriptor.getBackPanelDescriptor() != null){
            model.setBackButtonEnabled(Boolean.TRUE);
        } else{
            model.setBackButtonEnabled(Boolean.FALSE);
        }
        //  If the panel in question has one or more panels in front of it,
        //  enable the next button. Otherwise, disable it.
 
        if (descriptor.getNextPanelDescriptor() != null){
            model.setNextFinishButtonEnabled(Boolean.TRUE);
        } else{
            model.setNextFinishButtonEnabled(Boolean.FALSE);
        }
        //  If the panel in question is the last panel in the series, change
        //  the Next button to Finish. Otherwise, set the text back to Next.
        
        if (descriptor.getNextPanelDescriptor() instanceof WizardPanelDescriptor.FinishIdentifier) {
            model.setNextFinishButtonText(Wizard.FINISH_TEXT);

        } else {
            model.setNextFinishButtonText(Wizard.NEXT_TEXT);

        }
        
    }
    /**
     * Inner class to get all atomic classes in a background thread.
     * @author Lorenz Buehmann
     *
     */
    class ConceptRetriever extends SwingWorker<Set<NamedClass>, NamedClass> {
		private Object nextPanelID;
		private ClassChoosePanel owlClassPanel;
		
		public ConceptRetriever(Object nextPanelDescriptor) {

			nextPanelID = nextPanelDescriptor;
			owlClassPanel = ((ClassChoosePanelDescriptor) wizard.getModel().getPanelHashMap().get(nextPanelID)).getOwlClassPanel();
		}

		@Override
		public Set<NamedClass> doInBackground() {
			wizard.getStatusBar().showProgress(true);
			wizard.getStatusBar().setProgressTitle("retrieving atomic classes");
			
			Set<NamedClass> classes = OREManager.getInstance().getPelletReasoner().getNamedClasses();
			
			return classes;
		}

		@Override
		public void done() {
			Set<NamedClass> classes = null;
			try {
				classes = get();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ExecutionException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			owlClassPanel.getClassesTable().addClasses(classes);
			wizard.getStatusBar().showProgress(false);
			wizard.getStatusBar().setProgressTitle("atomic classes loaded");
		}

	}
    
    class ClassificationWorker extends SwingWorker<Void, Void>{
		
		private StatusBar statusBar;
		
		public ClassificationWorker(StatusBar statusBar) {
			this.statusBar = statusBar;
//			OREManager.getInstance().getPelletReasoner().addProgressMonitor(new ClassificationProgressMonitor());
			
		}

		@Override
		public Void doInBackground() {
			statusBar.showProgress(true);
			wizard.getDialog().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
			
			statusBar.setProgressTitle("classifying ontology");
			OREManager.getInstance().getPelletReasoner().classify();

			return null;
		}

		@Override
		public void done() {
			wizard.getDialog().setCursor(null);
			statusBar.showProgress(false);
			statusBar.setProgressTitle("");
		}

	}
    
    
}
