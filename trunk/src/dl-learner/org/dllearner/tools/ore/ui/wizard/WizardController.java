/**
 * Copyright (C) 2007-2008, Jens Lehmann
 *
 * This file is part of DL-Learner.
 * 
 * DL-Learner is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * DL-Learner is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.dllearner.tools.ore.ui.wizard;


import java.awt.event.ActionListener;
import java.util.List;

import javax.swing.JOptionPane;

import org.dllearner.learningproblems.EvaluatedDescriptionClass;
import org.dllearner.tools.ore.LearningManager;
import org.dllearner.tools.ore.OREManager;
import org.dllearner.tools.ore.ui.wizard.descriptors.AutoLearnPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.ClassChoosePanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.InconsistencyExplanationPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.IntroductionPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.KnowledgeSourcePanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.ManualLearnPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.RepairPanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.SavePanelDescriptor;
import org.dllearner.tools.ore.ui.wizard.descriptors.UnsatisfiableExplanationPanelDescriptor;
import org.mindswap.pellet.utils.SetUtils;

/**
 * This class is responsible for reacting to events generated by pushing any of the
 * three buttons, 'Next', 'Previous', and 'Cancel.' Based on what button is pressed,
 * the controller will update the model to show a new panel and reset the state of
 * the buttons as necessary.
 * @author Lorenz Buehmann
 */
public class WizardController implements ActionListener {
    
    private Wizard wizard;
    
    /**
     * This constructor accepts a reference to the Wizard component that created it,
     * which it uses to update the button components and access the WizardModel.
     * @param w A callback to the Wizard component that created this controller.
     */    
    public WizardController(Wizard w) {
        wizard = w;
    }

    /**
     * Calling method for the action listener interface. This class listens for actions
     * performed by the buttons in the Wizard class, and calls methods below to determine
     * the correct course of action.
     * @param evt The ActionEvent that occurred.
     */    
    public void actionPerformed(java.awt.event.ActionEvent evt) {
        
        if (evt.getActionCommand().equals(Wizard.CANCEL_BUTTON_ACTION_COMMAND)){
            cancelButtonPressed();
        } else if (evt.getActionCommand().equals(Wizard.BACK_BUTTON_ACTION_COMMAND)){
            backButtonPressed();
        } else if (evt.getActionCommand().equals(Wizard.NEXT_BUTTON_ACTION_COMMAND)){
            nextButtonPressed();
        }
    }
    
    
    
    private void cancelButtonPressed() {
        
        wizard.close(Wizard.CANCEL_RETURN_CODE);
    }

    private void nextButtonPressed() {
 
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor currentPanelDescriptor = model.getCurrentPanelDescriptor();
        OREManager ore = OREManager.getInstance();
        //  If it is a finishable panel, close down the dialog. Otherwise,
        //  get the ID that the current panel identifies as the next panel,
        //  and display it.
        
        Object nextPanelDescriptor = currentPanelDescriptor.getNextPanelDescriptor();
        WizardPanelDescriptor nextDescriptor = model.getPanelHashMap().get(nextPanelDescriptor);
  
		if (currentPanelDescriptor.getPanelDescriptorIdentifier().equals(
				KnowledgeSourcePanelDescriptor.IDENTIFIER)) {

			if (!ore.consistentOntology()) {

				int n = showInconsistentOntologyWarning();

				if (n == JOptionPane.NO_OPTION) {
					nextPanelDescriptor = KnowledgeSourcePanelDescriptor.IDENTIFIER;
				} else {
					InconsistencyExplanationPanelDescriptor incDescriptor = new InconsistencyExplanationPanelDescriptor();
					incDescriptor.init();
					wizard.registerWizardPanel(
							InconsistencyExplanationPanelDescriptor.IDENTIFIER,
							incDescriptor);
					nextPanelDescriptor = InconsistencyExplanationPanelDescriptor.IDENTIFIER;
				}
			} else {
				if (ore.getReasoner().getInconsistentClasses().size() > 0) {
					UnsatisfiableExplanationPanelDescriptor unsatDescriptor = new UnsatisfiableExplanationPanelDescriptor();
					unsatDescriptor.init();
					wizard.registerWizardPanel(
							UnsatisfiableExplanationPanelDescriptor.IDENTIFIER,
							unsatDescriptor);
					nextPanelDescriptor = UnsatisfiableExplanationPanelDescriptor.IDENTIFIER;
					wizard.setCurrentPanel(nextPanelDescriptor);
					unsatDescriptor.fillUnsatisfiableClassesList();
				} else {
					nextPanelDescriptor = ClassChoosePanelDescriptor.IDENTIFIER;
					((ClassChoosePanelDescriptor) nextDescriptor).resetPanel();
					
				}
			}
		} else if (currentPanelDescriptor.getPanelDescriptorIdentifier().equals(InconsistencyExplanationPanelDescriptor.IDENTIFIER)) {
			ore.getReasoner().classify();
			if (ore.getReasoner().getInconsistentClasses().size() > 0) {
				UnsatisfiableExplanationPanelDescriptor unsatDescriptor = new UnsatisfiableExplanationPanelDescriptor();
				unsatDescriptor.init();
				wizard.registerWizardPanel(
						UnsatisfiableExplanationPanelDescriptor.IDENTIFIER,
						unsatDescriptor);
				nextPanelDescriptor = UnsatisfiableExplanationPanelDescriptor.IDENTIFIER;
			} else {
				nextPanelDescriptor = ClassChoosePanelDescriptor.IDENTIFIER;
				((ClassChoosePanelDescriptor) nextDescriptor).resetPanel();
			
			}
		} else if (currentPanelDescriptor.getPanelDescriptorIdentifier().equals(UnsatisfiableExplanationPanelDescriptor.IDENTIFIER)) {
			nextPanelDescriptor = ClassChoosePanelDescriptor.IDENTIFIER;
			
		} 
//		else if (currentPanelDescriptor.getPanelDescriptorIdentifier().equals(ClassChoosePanelDescriptor.IDENTIFIER)) {
//			ore.makeOWAToCWA();
//			ore.setLearningProblem();
//			LearningPanelDescriptor learnDescriptor = ((LearningPanelDescriptor) model
//					.getPanelHashMap().get(nextPanelDescriptor));
//			learnDescriptor.resetPanel();

		 else if(nextPanelDescriptor.equals(ManualLearnPanelDescriptor.IDENTIFIER)){
			ManualLearnPanelDescriptor learnDescriptor = ((ManualLearnPanelDescriptor) model
					.getPanelHashMap().get(nextPanelDescriptor));
			learnDescriptor.resetPanel();
			
			
		} else if(nextPanelDescriptor.equals(ClassChoosePanelDescriptor.IDENTIFIER)){
			ClassChoosePanelDescriptor classChoose = ((ClassChoosePanelDescriptor) model
					.getPanelHashMap().get(nextPanelDescriptor));
			classChoose.resetPanel();
		} else if(nextPanelDescriptor.equals(AutoLearnPanelDescriptor.IDENTIFIER)){
			((ClassChoosePanelDescriptor)currentPanelDescriptor).setAutoLearningOptions();
			AutoLearnPanelDescriptor learnDescriptor = ((AutoLearnPanelDescriptor) model
					.getPanelHashMap().get(nextPanelDescriptor));
			learnDescriptor.resetPanel();
			learnDescriptor.fillClassesTable();
		}
		else if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(AutoLearnPanelDescriptor.IDENTIFIER)){
			AutoLearnPanelDescriptor descriptor = (AutoLearnPanelDescriptor)currentPanelDescriptor;
			List<List<EvaluatedDescriptionClass>> descriptions = descriptor.getSelectedDescriptions();
			if(!SetUtils.union(descriptions.get(0), descriptions.get(1)).isEmpty()){
				LearningManager.getInstance().setNewDescriptions(descriptions);
			}
			
		} else if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(ManualLearnPanelDescriptor.IDENTIFIER)){
			OREManager oreMan = OREManager.getInstance();
			oreMan.getModifier().addNewClassDescription(oreMan.getCurrentClass2Learn(), 
					oreMan.getNewClassDescription().getDescription());
		}
			
		else if(nextPanelDescriptor.equals(RepairPanelDescriptor.IDENTIFIER)){
				RepairPanelDescriptor repair = ((RepairPanelDescriptor) model
						.getPanelHashMap().get(nextPanelDescriptor));
				if(LearningManager.getInstance().isManualLearningMode()){
					repair.setManualPanel(true);
					repair.fillExamplesLists();
				} else {
					repair.setManualPanel(false);
					repair.fillExamplesLists();
				}
				
			
			
			
		} else if (nextPanelDescriptor.equals(SavePanelDescriptor.IDENTIFIER)) {

//			Description newDesc = ore.getNewClassDescription().getDescription();
//			Description oldClass = ore.getCurrentClass2Learn();
//
//			List<OWLOntologyChange> changes = ore.getModifier()
//					.rewriteClassDescription(newDesc, oldClass);
//			((RepairPanelDescriptor) currentPanelDescriptor)
//					.getOntologyChanges().addAll(changes);

		}
		if(nextPanelDescriptor.equals(RepairPanelDescriptor.IDENTIFIER)){
			RepairPanelDescriptor repair = ((RepairPanelDescriptor) model
					.getPanelHashMap().get(nextPanelDescriptor));
			if(LearningManager.getInstance().isManualLearningMode()){
				repair.setManualPanel(true);
				repair.fillExamplesLists();
			} else {
				repair.setManualPanel(false);
				repair.fillExamplesLists();
			}
	}
		if (nextPanelDescriptor instanceof WizardPanelDescriptor.FinishIdentifier) {
			wizard.close(Wizard.FINISH_RETURN_CODE);
		} else {
			wizard.setCurrentPanel(nextPanelDescriptor);
		}
        
        //TODO
        refreshLeftPanel(nextPanelDescriptor);
  
    }
    
    
    private void backButtonPressed() {
 
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor currentPanelDescriptor = model.getCurrentPanelDescriptor();
 
        //  Get the descriptor that the current panel identifies as the previous
        //  panel, and display it.
        
        Object backPanelDescriptor = currentPanelDescriptor.getBackPanelDescriptor();        
        
        if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(RepairPanelDescriptor.IDENTIFIER)){
        	RepairPanelDescriptor repairDescriptor = (RepairPanelDescriptor) currentPanelDescriptor;
        	if(repairDescriptor.getOntologyChanges().size() > 0){
	        	if (JOptionPane.showConfirmDialog(wizard.getDialog(),
				        "All changes will be lost!", "Warning!", 
				        JOptionPane.YES_NO_OPTION)
				     == JOptionPane.YES_OPTION){
	
	        		OREManager.getInstance().getModifier().undoChanges(repairDescriptor.getOntologyChanges());
	        		repairDescriptor.getOntologyChanges().clear();
					
				} else {
					backPanelDescriptor = RepairPanelDescriptor.IDENTIFIER;
				}
        	}  	
        } else if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(ManualLearnPanelDescriptor.IDENTIFIER)){
        	ManualLearnPanelDescriptor learnDescriptor = (ManualLearnPanelDescriptor) currentPanelDescriptor;
        	if(learnDescriptor.getLa() != null && learnDescriptor.getLa().isRunning()){
        		learnDescriptor.getLa().stop();
        		learnDescriptor.getTimer().cancel();
        	}
        } else if(currentPanelDescriptor.getPanelDescriptorIdentifier().equals(ClassChoosePanelDescriptor.IDENTIFIER)){
        	if(OREManager.getInstance().getReasoner().getInconsistentClasses().size() > 0){
        		backPanelDescriptor = UnsatisfiableExplanationPanelDescriptor.IDENTIFIER;
        	}
        }
        
//        if(backPanelDescriptor.equals("LEARNING_PANEL")){
//        	RepairPanelDescriptor repairDescriptor = (RepairPanelDescriptor) currentPanelDescriptor;
//        	if(repairDescriptor.getOntologyChanges().size() > 0){
//	        	if (JOptionPane.showConfirmDialog(wizard.getDialog(),
//				        "All changes will be lost!", "Warning!", 
//				        JOptionPane.YES_NO_OPTION)
//				     == JOptionPane.YES_OPTION){
//	
//	        		OREManager.getInstance().getModifier().undoChanges(repairDescriptor.getOntologyChanges());
//	        		repairDescriptor.getOntologyChanges().clear();
//					
//				} else {
//					backPanelDescriptor = RepairPanelDescriptor.IDENTIFIER;
//				}
//        	} 
//        	
//        	
//        	
//        } else if(backPanelDescriptor.equals("CLASS_CHOOSE_OWL_PANEL")){
//        	LearningPanelDescriptor learnDescriptor = (LearningPanelDescriptor) currentPanelDescriptor;
//        	if(learnDescriptor.getLa() != null){
//        		learnDescriptor.getLa().stop();
//        		learnDescriptor.getTimer().cancel();
//        	}
//        	
//        }
        wizard.setCurrentPanel(backPanelDescriptor);
        refreshLeftPanel(backPanelDescriptor);
        
    }
    
    void refreshLeftPanel(Object panelDescriptor){
    	
    	if(panelDescriptor.equals(IntroductionPanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(0);
        } else
    	if(panelDescriptor.equals(KnowledgeSourcePanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(1);
        } else 
    	if(panelDescriptor.equals(ClassChoosePanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(3);
        } else
    	if(panelDescriptor.equals(ManualLearnPanelDescriptor.IDENTIFIER) || panelDescriptor.equals(AutoLearnPanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(4);
        } else 
    	if(panelDescriptor.equals(RepairPanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(5);
        } else
    	if(panelDescriptor.equals(SavePanelDescriptor.IDENTIFIER)){
        	wizard.setLeftPanel(6);
        } else {
    	
        	wizard.setLeftPanel(2);
        }
    	
    	
        
    }
    
    private int showInconsistentOntologyWarning(){
		String infoString = "<html>Can not do reasoning with inconsistent ontologies, " +
				"since everything is equivalent to OWL:Nothing" +
				"<UL>" +
				"<LI>Press 'Yes' and try to repair the ontology" +
				"<LI>Press 'No' and choose another ontology or exit" +
				"</UL>";

		
		Object[] options = {"Yes",
        "No"};

		int n = JOptionPane.showOptionDialog(wizard.getDialog(),
			    infoString,
			    "Inconsistent ontology loaded!",
			    JOptionPane.YES_NO_OPTION,
			    JOptionPane.WARNING_MESSAGE,
			    null,     //do not use a custom Icon
			    options,  //the titles of buttons
			    options[0]); //default button title
		
		return n;
		
    }
    
    

    
    void resetButtonsToPanelRules() {
    
        //  Reset the buttons to support the original panel rules,
        //  including whether the next or back buttons are enabled or
        //  disabled, or if the panel is finishable.
        
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
        
        model.setCancelButtonText(Wizard.CANCEL_TEXT);
//        model.setCancelButtonIcon(Wizard.CANCEL_ICON);
        
        //  If the panel in question has another panel behind it, enable
        //  the back button. Otherwise, disable it.
        
        model.setBackButtonText(Wizard.BACK_TEXT);

        
        if (descriptor.getBackPanelDescriptor() != null){
            model.setBackButtonEnabled(Boolean.TRUE);
        } else{
            model.setBackButtonEnabled(Boolean.FALSE);
        }
        //  If the panel in question has one or more panels in front of it,
        //  enable the next button. Otherwise, disable it.
 
        if (descriptor.getNextPanelDescriptor() != null){
            model.setNextFinishButtonEnabled(Boolean.TRUE);
        } else{
            model.setNextFinishButtonEnabled(Boolean.FALSE);
        }
        //  If the panel in question is the last panel in the series, change
        //  the Next button to Finish. Otherwise, set the text back to Next.
        
        if (descriptor.getNextPanelDescriptor() instanceof WizardPanelDescriptor.FinishIdentifier) {
            model.setNextFinishButtonText(Wizard.FINISH_TEXT);

        } else {
            model.setNextFinishButtonText(Wizard.NEXT_TEXT);

        }
        
    }
    
}
