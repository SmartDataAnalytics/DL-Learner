/**
 * Uncle Example
 *
 * possible solution: (male AND (EXISTS hasSibling.EXISTS hasChild.TOP 
 *                    OR EXISTS married.EXISTS hasSibling.EXISTS hasChild.TOP))
 *
 * The complexity of the learning task depends to a large extend on the length
 * of the smallest possible solution. For this reason this is a very hard 
 * learning task, despite the simplicity of the background knowledge.
 *
 * Note: Currently the data is insufficient, i.e. it allows the algorithm to
 *       to find shorter correct solutions than the desired one above.
 */

writeDIGProtocol = false;
digProtocolFile = "dig_uncle_fact.txt";

/** background knowledge **/
BOTTOM = (male AND female).
Functional(married).
Symmetric(married).
Symmetric(hasSibling). 

male(heinrich).
male(jan).
male(markus).
male(alfred).
male(hans).
male(heinz).
male(alex).
female(susi).
female(anna).
female(maria).
female(katrin).
female(johanna).
female(mandy).
female(miriam).
female(hanna).

married(heinrich,susi).
married(anna,jan).
married(alfred,katrin).
married(hans,johanna).

hasSibling(susi,anna).
hasSibling(alfred,maria).
hasSibling(alfred,heinz).
hasSibling(heinz,maria).
hasSibling(johanna,mandy).
hasSibling(hanna,alex).

hasChild(anna,alfred).
hasChild(anna,maria).
hasChild(anna,heinz).
hasChild(jan,alfred).
hasChild(jan,maria).
hasChild(jan,heinz).
hasChild(maria,markus).
hasChild(alfred,hans).
hasChild(katrin,hans).
hasChild(mandy,miriam).
hasChild(hanna,jan).

/** examples **/
+uncle(heinrich).
+uncle(alfred).
+uncle(heinz).
+uncle(hans).
+uncle(alex).
-uncle(jan).
-uncle(markus).
-uncle(susi).
-uncle(anna).
-uncle(maria).
-uncle(katrin).
-uncle(johanna).
-uncle(mandy).
-uncle(miriam).
-uncle(hanna).
